#!/usr/bin/env python

#Within each sample, group by barcode; assign each barcode a list of zOTUs
#for each read that contains that barcode (i.e. list can contain redundancies)
#INPUT:  Fasta file with droplet barcode and zOTU information in the header
#OUTPUT: A dictionary where each sampID maps to a dictionary of droplet 
#	 barcodes:[zOTU1, zOTU1, zOTU2, ...]
def createBarcodeDict(inFileName):
    inFile = open(inFileName, 'r')
    barcodeSamples = {}
    for line in inFile:
        if '>' in line:
            line = line.strip().split(';')
            samp = line[0].split('_')[0].replace('>','')
            bc = line[0].split('droplet_bc=')[1]
            otu = line[1]
            if samp not in barcodeSamples:
                barcodeSamples[samp] = {bc:[otu]}
            else:
                if bc not in barcodeSamples[samp]:
                    barcodeSamples[samp][bc] = [otu]
                else:
                    barcodeSamples[samp][bc].append(otu)
    inFile.close()
    return barcodeSamples

#Summarize the richness of the barcoding data from different samples into a
#log file
#INPUT:  barcodeDict generated by createBarcodeDict
#	 list of sampleIDs in desired order
#OUTPUT: path to output log file, a tab-delimited summary of barcode patterns
#	     for each input sample
def summarizeBarcoding(barcodeDict, sampIDs, outFileName):
    outFile = open(outFileName, 'w')
    outFile.write('#sample\ttotal_barcodes\tsingletons\treplicates\tmultiplets\n')
    for s in sampIDs:
        if s not in barcodeDict:
            continue
        outList = [s]
        outList.append(str(len(barcodeDict[s])))
        singletons = 0
        replicates = 0
        multiplets = 0
        for bc in barcodeDict[s]:
            if len(barcodeDict[s][bc]) == 1:
                singletons += 1
            elif(len(set(barcodeDict[s][bc])) == 1):
                replicates += 1
            elif(len(set(barcodeDict[s][bc])) > 1):
                multiplets += 1
        outList = outList + map(str, [singletons, replicates, multiplets])
        outFile.write('\t'.join(outList) + '\n')
    outFile.close()
