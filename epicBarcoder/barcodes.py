#!/usr/bin/env python

import pandas as pd
from itertools import combinations
from . import taxonomy as tx
from scipy.stats import poisson
import math

#Within each sample, group by barcode; assign each barcode a list of zOTUs
#for each read that contains that barcode (i.e. list can contain redundancies)
#INPUT:  Fasta file with droplet barcode and zOTU information in the header
#OUTPUT: A dictionary where each sampID maps to a dictionary of droplet 
#	 barcodes:[zOTU1, zOTU1, zOTU2, ...]
def createBarcodeDict(inFileName):
    inFile = open(inFileName, 'r')
    barcodeSamples = {}
    for line in inFile:
        if '>' in line:
            line = line.strip().split(';')
            samp = line[0].split('_')[0].replace('>','')
            bc = line[0].split('droplet_bc=')[1]
            otu = line[1]
            if samp not in barcodeSamples:
                barcodeSamples[samp] = {bc:[otu]}
            else:
                if bc not in barcodeSamples[samp]:
                    barcodeSamples[samp][bc] = [otu]
                else:
                    barcodeSamples[samp][bc].append(otu)
    inFile.close()
    return barcodeSamples

#Summarize the richness of the barcoding data from different samples into a
#log file
#INPUT:  barcodeDict generated by createBarcodeDict
#	 list of sampleIDs in desired order
#OUTPUT: path to output log file, a tab-delimited summary of barcode patterns
#	     for each input sample
def summarizeBarcoding(barcodeDict, sampIDs, outFileName):
    outFile = open(outFileName, 'w')
    outFile.write('#sample\ttotal_barcodes\tsingletons\treplicates\tmultiplets\n')
    for s in sampIDs:
        if s not in barcodeDict:
            continue
        outList = [s]
        outList.append(str(len(barcodeDict[s])))
        singletons = 0
        replicates = 0
        multiplets = 0
        for bc in barcodeDict[s]:
            if len(barcodeDict[s][bc]) == 1:
                singletons += 1
            elif(len(set(barcodeDict[s][bc])) == 1):
                replicates += 1
            elif(len(set(barcodeDict[s][bc])) > 1):
                multiplets += 1
        outList = outList + list(map(str, [singletons, replicates, multiplets]))
        outFile.write('\t'.join(outList) + '\n')
    outFile.close()

#Calculate abundances of background OTUs based on singleton barcodes
#Background OTUs defined as unique taxonomic classifications
#INPUT:  barcode dictionary (output of createBarcodeDict)
#        taxonomic dictionary (output of importSintax with 'final' setting)
#OUTPUT: relative abundance pandas dataframe, with sample IDs in the columns and
#        tOTUs as row indexes
def tOTU_singletonAbundances(barcodeDict, taxDict):
    otuDf = tx.tOTUmap(taxDict)
    abundances = {}
    totals = {}
    for s in barcodeDict:
        total = 0
        backgroundOTU = {}
        for bc in barcodeDict[s]:
            #If there is one unique barcode with only one sequence mapped to it
            #(true barcode singleton)
            if len(barcodeDict[s][bc]) == 1:
                zOTU = barcodeDict[s][bc][0]
                tOTU = otuDf['tOTU'][zOTU]
                if tOTU not in backgroundOTU:
                    backgroundOTU[tOTU] = 1
                else:
                    backgroundOTU[tOTU] += 1
                total += 1
        abundances[s] = backgroundOTU
        totals[s] = total
    #Convert abundance counts to relative abundances
    relAbundances = {}
    for s in abundances:
        relAbund = {}
        for otu in abundances[s]:
            relAbund[otu] = float(abundances[s][otu]) / totals[s]
        relAbundances[s] = relAbund
    relDf = pd.DataFrame.from_dict(relAbundances).fillna(0)
    return relDf

#Create a dataframe mapping each unique taxonomy-otu (tOTU) pair to the number
#of barcodes supporting it
#INPUT:  barcode dictionary (output of createBarcodeDict)
#        taxonomic dictionary (output of importSintax with 'final' setting)
#OUTPUT: a dataframe with tOTU pairs separated by a double underscore in the
#	     rows, sample IDs in the columns, and the number of droplet barcodes
#	     supporting the pair as data
def tOTU_quantifyPairs(barcodeDict, taxDict):
    otuDf = tx.tOTUmap(taxDict)
    pairDict = {}
    for s in barcodeDict:
        pairs = {}
        for bc in barcodeDict[s]:
            otuList = barcodeDict[s][bc]
            if len(otuList) > 1:
                uniqueOTUs = list(set(otuList))
                if len(uniqueOTUs) > 1:
                    tOTUs = []
                    for zOTU in uniqueOTUs:
                        tOTUs.append(otuDf['tOTU'][zOTU])
                    unique_tOTUs = list(set(tOTUs))
                    if len(unique_tOTUs) > 1:
                        pairList = []
			#Sort observed pairs and join into unique ids
                        for comb in combinations(unique_tOTUs, 2):
                            sortComb = list(comb)
                            sortComb.sort()
                            pairList.append('__'.join(sortComb))
                        pairList = list(set(pairList))
                        for p in pairList:
                            if p not in pairs:
                                pairs[p] = 1
                            else:
                                pairs[p] += 1
        pairDict[s] = pairs
    pairDf = pd.DataFrame.from_dict(pairDict).fillna(0)
    return pairDf

#Make iTol significant connection files based on poisson modeling of relative
#abundance
#INPUT:  pairDf, a dataframe with samples as columns, otu pairs separated by
#            '__' as rows, and number of droplet barcodes as data. Generated by
#	     e.g. tOTU_quantifyPairs()
#        abundanceDf, a dataframe with samples as columns, otus as rows, and
#	     relative abundance data
#        cutoff, a p-value float used to cutoff significant associations
#        barcodingLog, path to log file for total barcode counts
#OUTPUT: posDf, dataframe with significant positive pairings for every sample
#        negDf, dataframe with significant negative pairings for every sample
def pickSigPairs(pairDf, abundanceDf, barcodingLog, cutoff):
    #Import total singleton counts to use as estimates of cell count
    totals = {}
    with open(barcodingLog, 'r') as logFile:
        for line in logFile:
            if '#' not in line:
                line = line.strip().split('\t')
                totals[line[0]] = float(line[2])
    posPairs = {}
    negPairs = {}
    for samp in pairDf:
        pos = {}
        neg = {}
        for pair in list(pairDf.index.values):
            otu1 = pair.split('__')[0]
            otu2 = pair.split('__')[1]
            try:
                a1 = abundanceDf[samp][otu1]
            except KeyError:
                a1 = 0.0
            try:
                a2 = abundanceDf[samp][otu2]
            except KeyError:
                a2 = 0.0
            x = pairDf[samp][pair]
            mu = a1 * a2 * totals[samp]
            p = poisson.pmf(x, mu)
            bonferroni_cutoff = cutoff / len(pairDf[samp])
            if p < bonferroni_cutoff:
                if p == 0.0:
                    p = 1e-100
                if x < mu:
                    neg[pair] = math.fabs(math.log10(p))
                else:
                    pos[pair] = math.fabs(math.log10(p))
        posPairs[samp] = pos
        negPairs[samp] = neg
    posDf = pd.DataFrame.from_dict(posPairs).fillna(0)
    negDf = pd.DataFrame.from_dict(negPairs).fillna(0)
    return posDf, negDf
